---
title: Deadlines and goals in a software project
date: 19.04.2013
author: Michael Hughes
tags: [Philosophy,Design]
---

Summary
    I'm going to abuse an old addage--Every software project has it's day. Today's
    article is not about solving a specific technical problem. Instead I'm going
    to offer some thoughts on whether software projects are ever complete and what
    I should be striving for in a solution.

----

We'll start with the idea of being done. It's likely safe to say that many things have
a specific and ideal state that can be described as done. For example, when I brew a
batch of brew there is a point where a particular batch is done. The batch has been cooked,
fermented, conditioned, bottled, distributed, and aged--at this point not calling it done
and then drinking it would be a crying shame. I've never felt this kind of completeness 
when working on a software solution. There's another addage (maybe, enough people refer to it),
software is never done, only abandoned. This is a somewhat grim view of the final stages
of a solution's lifecycle, but it's probably picture of reality than other comparisons.

It's worth addressing systems that have been around for some time now which may be used
as counterpoint to the idea that software is never complete. During the late 90's COBOL
programmers made good money fixing date and time bugs in software--software that had
existed for some time prior to that decade. I'd like to imagine that for a time heads of
IT departments at some enterprises forgot that 
