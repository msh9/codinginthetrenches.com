---
title: Closures, Javascript, and Objects - Part I
author: Michaelhughes
date: 21.09.2011
filter: [rst, ]
tags: [Javascript, OOP]
---

**Update**: I recently added a `short post about nested functions <http://mhughes.info/?p=87>`_ using Javascript as an example.

--------------


Javascript is an object oriented language and with the fast JS engines of modern browsers it's possible to `create some impressive things with the language <http://kevs3d.co.uk/dev/asteroids/>`_. As first glance though Javascript appears to be a procedural language and lacking in the basic semantics to define classes and instantiate objects.

Javascript does have objects though, we just need to combine some language elements to create them. This is the first post of two on creating objects in Javascript, this week's post will focus on a simpler method of class definition and object creation in Javascript. Next week's post will look at a more efficient, but slightly more complex method of implementing objects.

--------------


To create objects in Javascript we'll need to borrow some concepts from functional programming. In particular we will need the following two concepts: closures and functions as first class entities.

Wikipedia has a nice `definition <http://en.wikipedia.org/wiki/Closure_%28computer_science%29>`_ of closures in the context of computer science. One way of think of closures which will be useful in the context of JS is that closures are defined by a namespace and a function, that is, a function and the variables that can be named inside the block of that function. An example:

::


   function o(z) {

     var x = 3;

     var y = 4;

     var f = function(z) {

        return x + y + z;

     }

     return f(z);

   o(5) // = 12

   }


Here the variables x,y, and f are all scoped within the function o, they are all members of the namespace defined by the function o. Calling o with the value 5 (``o(5)``) yields that return value of 12. The output of this function call should not be that surprising, the only unusual aspect of this example (from the perspective of C/C++) is that I have a nested function definition. A example which clearly demonstrates how closures are special is as follows:

::


   function o() {

     var x = 3;

     var y = 4;

     function f(z) {

        return x + y + z;

     }

     return f;

   }

   var myFunction = o();

   myFunction(5) // = 12


In this example we returned a reference to the caller that enabled a call to be made into the closure defined by the outer function. To be explicit the outer function forms a closure around the variables x and y, and the function f. The important take away is that after the function ``o()`` returns the environment in which f (the object returned) was created continues to exist as a closure. Furthermore as a client of ``o()`` we only have access to the item returned, f, and not the inner variables x and y.

Before making objects we need another concept from functional programming, in javascript functions are `first class entities <http://en.wikipedia.org/wiki/First-class_function>`_. We've already used one element of this concept when we nested one function within another, there is another useful application though. We can assign an *anonymous function object* to a variable name.

::


   var o = function() {

     var x = 3;

     var y = 4;

     var f = function(z) {

        return x + y + z;

     }

     return f;

   }

   var myFunction = o();

   myFunction(5) // = 12


This above example is nearly the same as the previous, but instead we make the function call through a variable name. The take away here is that in JS functions are treated similarly to other variables, in fact in JS functions are **objects** themselves. The final component we need to add is javascript's implicit object creation which will us to return a collection of things from a function call.

::


   var c = function() {

     obj = {};

     var x = 3;

     var y = 4;

     obj.f = function(z) { //map an anonymous function to the name f in the map obj

        return x + y + z;

     }

     obj.f2 = function(z) { //map another anonymous function to the name f2

       return x - y - z;

     }

     return obj;

   }

   var myObject = c();

   myObject.f(5) // = 12

   myObject.f2(5) // = -6


We now have a class definition, (``var c = function()...``), and an object instantiation (``var myObject = c()``) with state (variables x & y) and methods (f & f2). In short we have one of basic elements of OO programming, it just looks different.

The statement ``obj = {}`` bears some further discussion. The syntax being used is the same as described on Mozilla's developer network `here <https://developer.mozilla.org/en/JavaScript/Guide/Working_with_Objects#Using_Object_Initializers>`_, but instead of pre-populating the object, we first create the object, obj and then add methods and data to it. It is this implicitly created object combined with the closure of outer function that creates the an object for client code to use.

The key to this is that when the outer function is called it creates an environment (a closure) in which the inner function continues to execute in even after the outer function has returned. An implicitly created object is used to store public functions and variables, in this example the functions f and f2. Members of the closure that are not returned as part of the implicit object, obj become private data, for example the variables x and y above are `encapsulated <http://en.wikipedia.org/wiki/Encapsulation_%28computer_science%29>`_ within the object and cannot be accessed by clients of the object ``myObject``.

So far the examples have used only static data, but this works with more complex objects too.

`http://jsfiddle.net/m3CTK/ <http://jsfiddle.net/m3CTK/>`_

In the linked example we take data from a form and put it into a data transfer object that also has some minimal logic in it too. We then call the processing logic of the DTO and print out the results. The example is contrived but it shows the usage of public and private functions and data in JS, the basics of OOP.

Now while all of the above serves as a good introduction to some elements of objects in JS, there are better methods of creating objects which I'll cover in the next posting on this topic.

Â 
